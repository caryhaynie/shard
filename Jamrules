switch $(OS)
{
    case NT :
        CARGO ?= cargo.exe ;
        NASM ?= nasm.exe ;
        XARGO ?= xargo.exe ;
    case * :
        CARGO ?= cargo ;
        NASM ?= nasm ;
        POPD ?= popd ;
        PUSHD ?= pushd ;
        xargo ?= xargo ;
}

rule Nasm 
{
    local target = $(1) ;
    local asms = $(2) ; 
    local flags = $(3) ;

    for asm in $(asms)
    {
        SEARCH on $(asm) = $(SEARCH_SOURCE) ;
        local obj = $(asm:S=$(SUFOBJ):D=) ;
        local _t = $(asm:R=build) ;
        _t = $(_t:D) ;
        MakeLocate $(obj) : $(_t) ;
        Depends $(target) : $(obj) ;
        Depends $(obj) : $(asm) ;
        AS on $(obj) = $(NASM) ;
        ASFLAGS on $(obj) = $(flags) ;
        Nasm.As $(obj) : $(asm) ;
    }
}

rule Rust.Cargo
{
    local projdir = $(1) ;

    local target = $(projdir:G=<Cargo>) ;

    ACTION on $(target) = $(2) ;
    ACTION on $(target) ?= build ;
    cargoDir on $(target) = $(projdir) ;
    CARGO on $(target) ?= $(CARGO) ;

    Always $(target) ;
    NotFile $(target) ;
    
    return $(target) ;
}

rule Rust.Xargo
{
    local _oldCargo = $(CARGO) ;
    CARGO = $(XARGO) ;
    local ret = [ Rust.Cargo $(1) ] ;
    CARGO = $(_oldCargo) ;
    return $(ret) ;
}

rule Kernel
{
    local out_file = $(1) ;
    local platform = $(2) ;

    local _t = kernel.$(platform) ;

    NotFile $(_t) ;
    Depends $(_t) : $(out_file) ;
    Depends all : $(_t) ;

    local out_dir = build$(SLASH)$(platform) ;

    MakeLocate $(out_file) : $(out_dir) ;

    SubInclude TOP kernel ;

    local kernel_t = [ Rust.Xargo $(SUBDIR) ] ;

    Depends $(_t) : $(kernel_t) ;

    SubInclude TOP kernel arch $(platform) ;

    Nasm $(_t) : $(asms) : $(flags) ;
}

actions Nasm.As
{
    $(AS) $(ASFLAGS) $(2) -o $(1)
}

actions Rust.Cargo
{
    $(PUSHD) $(cargoDir)
    $(CARGO) $(ACTION)
    $(POPD)
}
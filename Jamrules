switch $(OS)
{
    case NT :
        CARGO ?= cargo.exe ;
        NASM ?= nasm.exe ;
        XARGO ?= xargo.exe ;
    case * :
        CARGO ?= cargo ;
        NASM ?= nasm ;
        POPD ?= popd ;
        PUSHD ?= pushd ;
        xargo ?= xargo ;
}

rule Nasm 
{
    local target = $(1) ;
    local asms = $(2) ; 
    local flags = $(3) ;

    for asm in $(asms)
    {
        SEARCH on $(asm) = $(SEARCH_SOURCE) ;
        local obj = $(asm:S=$(SUFOBJ):D=) ;
        local _t = $(asm:R=build) ;
        _t = $(_t:D) ;
        MakeLocate $(obj) : $(_t) ;
        Depends $(target) : $(obj) ;
        Depends $(obj) : $(asm) ;
        AS on $(obj) = $(NASM) ;
        ASFLAGS on $(obj) = $(flags) ;
        Nasm.As $(obj) : $(asm) ;
    }
}

rule Rust.Cargo
{
    Always $(>) ;
    NotFile $(>) ;
    Depends $(<) : $(>) ;
    CARGO on $(<) = $(CARGO) ;
    CMD on $(<) = $(3) ;
}

rule Kernel
{
    local out_file = $(1) ;
    local platform = $(2) ;

    _t = kernel.$(platform) ;

    NotFile $(_t) ;
    Depends $(_t) : $(out_file) ;
    Depends all : $(_t) ;

    local out_dir = build$(SLASH)$(platform) ;

    MakeLocate $(out_file) : $(out_dir) ;

    SubInclude TOP kernel ;

    SubInclude TOP kernel arch $(platform) ;
}

actions Nasm.As
{
    $(AS) $(ASFLAGS) $(2) -o $(1)
}

actions Rust.Cargo
{
    $(CARGO) $(CMD) -p $(>)
}